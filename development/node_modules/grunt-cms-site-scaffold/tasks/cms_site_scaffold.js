/*
 * grunt-cms-site-scaffold
 * https://github.com/Banno/grunt-cms-site-scaffold
 *
 * Copyright (c) 2013 Jack Viers
 * Licensed under the BANNO license.
 */

'use strict';
var path = require('path');
var request = require('request');
var when = require('when');
var m = require('when/node/function');
var jsonlint = require('jsonlint');
var ScaffoldRequestError = function(statusCode, body, message) {
  this.name = "ScaffoldRequestError";
  this.statusCode = statusCode || "";
  this.body = body || "";
  this.message = (message || "") + "\n statusCode: " + this.statusCode + "\n body: " + body;
};
ScaffoldRequestError.prototype = new Error();

module.exports = function(grunt) {

  function copyObject(obj) {
    var copy, keys, length;
    copy = {};
    for(keys = Object.keys(obj), length = keys.length; length; --length) {
        copy[keys[length - 1]] = obj[keys[length - 1]];
    }
    return copy;
  }

  // Please see the Grunt documentation for more information regarding task
  // creation: http://gruntjs.com/creating-tasks

  grunt.registerMultiTask('cms_site_scaffold', 'Uploads a site scaffold', function() {
    var done, options;
    done = this.async();
    // require email options
    this.requiresConfig("email", "password");
    // Merge task-specific and/or target-specific options with these defaults.
    options = this.options({
      url: 'http://artemis.local:9000',
      domain: 'artemis.local',
      ignoreMissing: false
    });
    // filter out non-extant files
    when.all(
      this.files.map(function(fileObject) {
        grunt.verbose.writeln("reading file object: " + JSON.stringify(fileObject));
        var fileObjectCopy = copyObject(fileObject);
        fileObjectCopy.src = fileObject.src.filter(function(filepath){
          var exists = grunt.file.exists(filepath);
          if(exists) {
            return true;
          } else if (!exists && options.ignoreMissing){
            grunt.verbose.writeln("Skipping non-extant filepath: " + filepath);
            return false;
          } else {
            grunt.fail.warn('Non-extant filepath: ' + filepath);
            return false;
          }
        });
        return fileObjectCopy;
      }).map(function(fileObject) {
        var fileObjectCopy = copyObject(fileObject);
        fileObjectCopy.src = fileObject.src.map(function(filepath){
          return path.resolve(filepath);
        });
        return fileObjectCopy;
      }).filter(function(fileObject) {
        return fileObject.src.length > 0;
      }).map(function(fileObject) {
        var json, deferred, promise;
        deferred = when.defer();
        promise = deferred.promise;
        try{
          json = jsonlint.parse(grunt.file.read(fileObject.src[0]));
          deferred.resolve(json);
        } catch (e) {
          deferred.reject(e);
        }
        return promise;
      })
    ).then(
      function(json) {
        return when.all(json.map(function(json){
          /*
           * Create 3 deferreds, one for the when.all promise array -- this is resolved when login and scaffold upload are
           * complete; one for the login request; and one for the scaffold upload;
           * On error on either the login or scaffold request, reject this when.all deferred with the error.
           * On success of the login request, execute the scaffold upload.
           * On success of the scaffold upload request, resolve this when.all deferred with the filepath that was uploaded.
           */
          var deferred, promise, loginCallback, scaffoldCallback, cb, loginDeferred, loginPromise, scaffoldDeferred, scaffoldPromise;
          deferred = when.defer();
          promise = deferred.promise;
          loginDeferred = when.defer();
          loginPromise = loginDeferred.promise;
          scaffoldDeferred = when.defer();
          scaffoldPromise = scaffoldDeferred;
          // helper for creating promisable callbacks for the login and scaffold requests.
          // necessary because the request lib doesn't follow node conventions -- it takes a 
          // callback with 3 arguments. To solve this, wrap the expected request callback
          // in a function with a bound promisable callback. Call on error or success as needed.
          cb = function(callback) {
            return function(error, res, body) {
              if(error) {
                callback(error);
              } else if(!error && res.statusCode !== 200) {
                callback(new ScaffoldRequestError(res.statusCode, res.body, "Scaffold Upload Request Failed"));
              } else {
                callback(null, {response: res, body: body});
              }
            };
          };
          // creates a bound promise for login. m is a monadic promise.
          loginCallback = m.createCallback(loginDeferred.resolver);
          // create a bound promise for scaffold upload. m is a monadic promise.
          scaffoldCallback = m.createCallback(scaffoldDeferred.resolver);
          //on success, kick off the upload. On error, reject the when.all deferred.
          loginDeferred.promise.then(function(responseObj) {
            grunt.verbose.writeln("Logged in. Uploading scaffold to " + options.url + '/_/api/scaffold');
            request.post({uri: options.url + '/_/api/scaffold', strictSSL: false, json: json, headers:{connection: "close"}}, cb(scaffoldCallback));
          }, function(error) {
            grunt.verbose.writeln("Login failed. Check your username and password.");
            deferred.reject(error);
          });
          //on success, return the uploaded filepath string. On error, reject the when.all deferred.
          scaffoldDeferred.promise.then(function(responseObj) {
            grunt.verbose.writeln("Success! Uploaded scaffold!");
            grunt.verbose.writeln("deferred: "+ deferred);
            deferred.resolve("Success! Uploaded scaffold!");
          }, function(error) {
            deferred.reject(error);
          });
          // begin the login and upload sequence.
          grunt.verbose.writeln("Logging in.");
          request.post({url: options.url + '/_/api/user/login', strictSSL: false, json:{email: grunt.config.get('email'), password: grunt.config.get('password')}}, cb(loginCallback));
          return promise;
        })).then(
          function(str) {
            grunt.log.writeln("Success!");
            done();
          },
          function(error) {
            grunt.fail.warn(error);
          }
        );
      },
      function(error){
        grunt.fail.warn(error);
      }
    );
  });
};
