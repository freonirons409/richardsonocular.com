/*
 * grunt-cms-upload
 * https://github.com/Banno/grunt-cms-upload
 *
 * Copyright (c) 2013 Banno LLC. All rights reserved.
 * Licensed under the BANNO license.
 */


'use strict';
var fs = require('fs');
var path = require('path');
var when = require('when');
var m = require('when/node/function');
var request = require('request');
var UploadRequestError = function(statusCode, body, message) {
  this.name = "UploadRequestError";
  this.statusCode = statusCode || "";
  this.body = body || "";
  this.message = (message || "") + "\n statusCode: " + this.statusCode + "\n body: " + this.body + "\n";
};
UploadRequestError.prototype = new Error();


module.exports = function(grunt) {

  // Please see the Grunt documentation for more information regarding task
  // creation: http://gruntjs.com/creating-tasks

  grunt.registerMultiTask('cms_upload', 'Uploads theme zips to the proper environment', function() {
    var done, errorCount, options, checkForErrorStatus;
    checkForErrorStatus = function(statusCode) {
      var successStatuses = [200, 302, 303, 301];
      grunt.verbose.writeln("statusCode=" + statusCode);
      return successStatuses.indexOf(statusCode) >= 0;
    };
    
    done = this.async();
    // required as command line arguments
    // task will fail if they are non-extant
    this.requiresConfig("email", "password");
    errorCount = 0;
    
    // Merge task-specific and/or target-specific options with these defaults.
    options = this.options({
      // default option url
      // defaults to artemis.local:9000
      url: 'http://artemis.local:9000',
      // default option ignoreMissing
      // defaults to false, 
      // meaning that if the file to
      // upload is missing, the build
      // will fail.
      ignoreMissing: false
      
    });

    grunt.verbose.writeln('Options: '+ JSON.stringify(options));

    // Create a promise that resolves on command exit
    // And fails on command error.
    // Failure should fail the build.
    // An upload failure can by bypassed
    // with the --force option
    when.all(this.files.map(function(fileObject) {
      var newFileObject, keys, length;
      // deep-copies an object
      newFileObject = JSON.parse(JSON.stringify(fileObject));
      grunt.verbose.writeln('fileObject: ' + JSON.stringify(fileObject));
      // make the paths absolute to avoid any funny business
      newFileObject.src = newFileObject.src.map(function(filepath){
        return path.resolve(filepath);
      });
      return newFileObject;
    }).filter(function(fileObject) {
      var length = fileObject.src.length;
      if(length > 0) {
        return true;
      } else if(options.ignoreMissing === true) {
        return false;
      } else {
        grunt.fail.warn('No existing files to upload. Please check if file(s) ' + JSON.stringify(fileObject.orig.src)  + ' exist(s).');
        return false;
      }
    }).map(function(fileObject){
      var deferred, promise, filepath, loginDeferred, loginPromise, loginCallback, uploadDeferred, uploadPromise, uploadCallback, cb, jar;
      jar = request.jar();
      filepath = fileObject.src[0];
      deferred = when.defer();
      promise = deferred.promise;
      loginDeferred = when.defer();
      loginPromise = loginDeferred.promise;
      uploadDeferred = when.defer();
      uploadPromise = uploadDeferred.promise;
      cb = function(callback) {
        return function(error, response, body) {
          if(error) {
            callback(error);
          } else if(!error && !checkForErrorStatus(response.statusCode)) {
            grunt.verbose.writeln(response.statusCode);
            callback(new UploadRequestError(response.statusCode, body));
          } else {
            callback(null, {response: response, body: body});
          }
        };
      };

      loginCallback = m.createCallback(loginDeferred.resolver);
      uploadCallback = m.createCallback(uploadDeferred.resolver);
      loginPromise.then(function (responseObj) {
        grunt.verbose.writeln("Logged in. Uploading " + filepath + "to " + options.url + "/_/editor/templates/assets/upload");
        var r = request({jar: jar, method: 'POST', url: options.url + '/_/editor/template/assets/upload', strictSSL: false}, cb(uploadCallback));
        var form = r.form();
        form.append('datafile', fs.createReadStream(filepath), {contentType:'application/zip', filename: path.basename(filepath)});
      }, function(error) {
        grunt.verbose.writeln("Error: " + error);
        grunt.verbose.writeln("Login failed. Check your username and password.");
        deferred.reject(["error", jar]);
      });
      uploadPromise.then(function(responseObj) {
        grunt.verbose.writeln("Success! Uploaded " + filepath);
        deferred.resolve([filepath, jar]);
      }, function(error) {
        grunt.verbose.writeln("error: " + error);
        deferred.reject([error, jar]);
      });
      grunt.verbose.writeln("Logging in.");
      request({jar: jar, method: 'POST', url: options.url + '/_/api/user/login', json: {email: grunt.config.get('email'), password: grunt.config.get('password')}, strictSSL:false}, cb(loginCallback));
      return promise;
    })).then(
      function reportUploadSuccess(successStrings) {
        var report = {count: 0, locations: ""};
        successStrings.forEach(function(ss) {
          var jar = ss[1];
          report.count++;
          report.locations = report.locations + "\n" + ss[0];
          request({method: 'DELETE', jar: jar, url: options.url + '/_/api/user/logout'});
        });
        
        return report;
      },
      function failBuild(error) {
        var jar = error[1];
        errorCount += 1;
        request({method: 'DELETE', jar: jar, url: options.url + '/_/api/user/logout'});
        grunt.fail.warn(error[0]);
      }
    ).then(
      function finalizeBuild(report){
        if(errorCount > 0) {
          grunt.fail.warn("Upload failed.");
        } else {
          done("Uploaded: " + report.count + "files. " + report.locations);
        }
      },
      // Shouldn't ever reach here, but jic
      function failBuild(error) {
        grunt.fail.warn(error);
      });
  });
};
